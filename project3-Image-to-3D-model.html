<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 3D Model Generator (Single File)</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone@7.24.8/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://unpkg.com/three@0.166.1/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.166.1/examples/js/controls/OrbitControls.js"></script>
    
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script> 
    
    <style>
        /* CSS Styles */
        body { background-color: white; color: black; }
        @media (prefers-color-scheme: dark) {
            body { background-color: #1f2937; color: white; }
        }
        /* Ensure the root element covers the screen to show the content */
        #root { min-height: 100vh; }
    </style>
</head>
<body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useCallback, useEffect, useRef } = React;
        const ReactDOM = window.ReactDOM;
        const THREE = window.THREE;
        
        // --- FIX APPLIED HERE ---
        // Access OrbitControls robustly. 
        // 1. Try THREE.OrbitControls (ideal UMD export)
        // 2. Fall back to window.OrbitControls (common legacy global export)
        const OrbitControls = window.THREE.OrbitControls || window.OrbitControls;
        
        if (typeof OrbitControls === 'undefined') {
            console.error("Fatal Error: OrbitControls failed to load. 3D Viewer will not function.");
            // Prevent further execution by throwing an error or rendering a fallback UI
        }
        
        // Icon setup from the previous fix remains (using lucide core library)
        const createIcon = (IconFunction) => ({ className, ...props }) => (
            <span 
                className={className} 
                dangerouslySetInnerHTML={{ __html: IconFunction().toSvg({ class: className, ...props }) }} 
            />
        );
        
        const Box = createIcon(lucide.Box);
        const Download = createIcon(lucide.Download);
        const Loader2 = createIcon(lucide.Loader2);
        const Upload = createIcon(lucide.Upload);
        const X = createIcon(lucide.X);
        
        // --- UTILITIES & MOCK UI ---
        
        const cn = (...classes) => classes.filter(Boolean).join(' ');

        // Mock Shadcn Components
        const Card = ({ className, ...props }) => (
            <div
                className={cn(
                    "rounded-xl border bg-white dark:bg-gray-800 text-gray-900 dark:text-white shadow",
                    className
                )}
                {...props}
            />
        );

        const Button = ({ className, variant = 'default', disabled, children, ...props }) => {
            let variantClasses = "bg-blue-600 text-white hover:bg-blue-700";
            
            if (variant === 'outline') {
                variantClasses = "border border-gray-300 dark:border-gray-700 bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-200 hover:bg-gray-50 dark:hover:bg-gray-700";
            }

            return (
                <button
                    className={cn(
                        "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors disabled:opacity-50 disabled:pointer-events-none h-10 px-4 py-2",
                        variantClasses,
                        className
                    )}
                    disabled={disabled}
                    {...props}
                >
                    {children}
                </button>
            );
        };

        // Mock Toast System
        const ToastState = {
            queue: [], listeners: [],
            subscribe(listener) { this.listeners.push(listener); return () => this.listeners = this.listeners.filter(l => l !== listener); },
            publish(toast) { this.queue.push(toast); this.listeners.forEach(listener => listener(toast)); },
        };
        const MockToastContainer = () => {
            const [currentToast, setCurrentToast] = useState(null);
            useEffect(() => {
                const unsubscribe = ToastState.subscribe((toast) => {
                    setCurrentToast(toast);
                    setTimeout(() => setCurrentToast(null), 3000);
                });
                return unsubscribe;
            }, []);

            if (!currentToast) return null;
            const baseClasses = "fixed bottom-4 right-4 p-4 rounded-md shadow-xl text-white max-w-sm transition-opacity duration-300 z-50";
            const variantClasses = currentToast.variant === "destructive" ? "bg-red-600 border border-red-700" : "bg-gray-800 border border-gray-700";

            return (
                <div className={`${baseClasses} ${variantClasses}`}>
                    <h3 className="font-bold text-lg">{currentToast.title}</h3>
                    <p className="text-sm">{currentToast.description}</p>
                </div>
            );
        };
        const useToast = () => ({ toast: (props) => ToastState.publish(props) });


        // --- LIBRARY/UTILITY CLASSES (Mocked) ---

        class DepthEstimator {
            async estimateDepth(img) {
                await new Promise(resolve => setTimeout(resolve, 1500)); 

                const width = img.naturalWidth;
                const height = img.naturalHeight;
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                
                const imageData = ctx.createImageData(width, height);
                const data = imageData.data;
                
                for (let y = 0; y < height; y++) {
                    const gradientValue = Math.floor(255 - (y / height) * 255); 
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        data[i] = gradientValue;       // R
                        data[i + 1] = gradientValue;   // G
                        data[i + 2] = gradientValue;   // B
                        data[i + 3] = 255;             // A
                    }
                }
                return imageData;
            }
        }

        class MeshGenerator {
            generateMeshFromDepth(depthMapData) {
                const { width, height, data } = depthMapData;
                const geometry = new THREE.BufferGeometry();
                
                const scaleFactor = 1.0; 
                const depthFactor = 0.5;
                
                const vertices = [];
                const uvs = [];
                const indices = [];
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        const depthValue = data[i]; 
                        
                        const zDisplacement = (depthValue / 255.0) * depthFactor;
                        
                        const vx = (x / width - 0.5) * scaleFactor;
                        const vy = (0.5 - y / height) * scaleFactor * (height / width); 
                        
                        vertices.push(vx, vy, zDisplacement);
                        uvs.push(x / (width - 1), 1.0 - y / (height - 1));
                    }
                }

                for (let y = 0; y < height - 1; y++) {
                    for (let x = 0; x < width - 1; x++) {
                        const a = x + y * width;
                        const b = x + 1 + y * width;
                        const c = x + 1 + (y + 1) * width;
                        const d = x + (y + 1) * width;

                        indices.push(a, d, b);
                        indices.push(b, c, d);
                    }
                }

                geometry.setIndex(indices);
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(vertices), 3));
                geometry.setAttribute('uv', new THREE.Float32BufferAttribute(new Float32Array(uvs), 2));

                geometry.computeVertexNormals();
                geometry.center(); 
                
                return geometry;
            }

            exportToOBJ(geometry) {
                const positions = geometry.getAttribute('position');
                const uvs = geometry.getAttribute('uv');
                const indices = geometry.getIndex();
                
                if (!positions || !indices) throw new Error("Geometry must have positions and indices for OBJ export.");

                let obj = '# 3D Model Generator Export\n';
                
                for (let i = 0; i < positions.count; i++) obj += `v ${positions.getX(i)} ${positions.getY(i)} ${positions.getZ(i)}\n`;
                if (uvs) for (let i = 0; i < uvs.count; i++) obj += `vt ${uvs.getX(i)} ${uvs.getY(i)}\n`;

                for (let i = 0; i < indices.count; i += 3) {
                    const v1 = indices.getX(i) + 1;
                    const v2 = indices.getX(i + 1) + 1;
                    const v3 = indices.getX(i + 2) + 1;
                    obj += `f ${v1}/${v1} ${v2}/${v2} ${v3}/${v3}\n`;
                }
                return obj;
            }

            downloadOBJ(objContent) {
                const blob = new Blob([objContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'generated_model.obj';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }
        }


        // --- REACT COMPONENTS ---

        const ImageUpload = ({ onImageSelect, selectedImage, isProcessing }) => {
            const [dragActive, setDragActive] = useState(false);

            const handleFileChange = useCallback((file) => {
                if (!file || !file.type.startsWith('image/')) return;
                onImageSelect(file);
            }, [onImageSelect]);

            const handleDrop = useCallback((e) => {
                e.preventDefault(); e.stopPropagation();
                setDragActive(false);
                if (e.dataTransfer.files && e.dataTransfer.files[0]) handleFileChange(e.dataTransfer.files[0]);
            }, [handleFileChange]);

            const handleDrag = useCallback((e) => {
                e.preventDefault(); e.stopPropagation();
                if (e.type === 'dragenter' || e.type === 'dragover') setDragActive(true);
                else if (e.type === 'dragleave') setDragActive(false);
            }, []);

            const handleClear = () => onImageSelect(null);
            const isDisabled = isProcessing;

            return (
                <div className={`p-4 border-2 rounded-lg transition-colors ${dragActive ? 'border-blue-500 bg-blue-50' : 'border-gray-300 bg-white dark:bg-gray-900'} ${isDisabled ? 'opacity-50 pointer-events-none' : ''}`}>
                    {!selectedImage ? (
                        <div 
                            className="flex flex-col items-center justify-center p-4 cursor-pointer"
                            onDragEnter={handleDrag} onDragLeave={handleDrag} onDragOver={handleDrag} onDrop={handleDrop}
                            onClick={() => document.getElementById('file-upload-input').click()}
                        >
                            <Upload className="w-8 h-8 text-gray-400 mb-2" />
                            <p className="text-sm text-gray-600 dark:text-gray-400 font-medium">
                                Drag & drop an image here, or <span className="text-blue-600 hover:text-blue-800">click to browse</span>
                            </p>
                            <input 
                                type="file" id="file-upload-input" accept="image/*" className="hidden" 
                                onChange={(e) => { if (e.target.files) handleFileChange(e.target.files[0]); }}
                            />
                        </div>
                    ) : (
                        <div className="relative">
                            <img src={selectedImage} alt="Uploaded Source" className="w-full h-auto rounded-lg max-h-64 object-contain" />
                            <button onClick={handleClear} className="absolute top-2 right-2 p-1 bg-red-500 text-white rounded-full hover:bg-red-600 transition-colors" aria-label="Remove image" disabled={isDisabled}>
                                <X className="w-4 h-4" />
                            </button>
                        </div>
                    )}
                </div>
            );
        };

        const DepthMapViewer = ({ depthMap }) => {
            const canvasRef = useRef(null);

            useEffect(() => {
                if (depthMap && canvasRef.current) {
                    const canvas = canvasRef.current;
                    canvas.width = depthMap.width;
                    canvas.height = depthMap.height;
                    const ctx = canvas.getContext('2d');
                    if (ctx) ctx.putImageData(depthMap, 0, 0);
                }
            }, [depthMap]);

            return (
                <div className="border border-gray-200 rounded-lg bg-gray-100 dark:bg-gray-900 flex items-center justify-center h-64 relative">
                    {depthMap ? (
                        <canvas ref={canvasRef} className="w-full h-full object-contain rounded-lg p-2" style={{ maxWidth: '100%', maxHeight: '100%', width: 'auto', height: 'auto' }} />
                    ) : (
                        <p className="text-gray-500">Depth map will be generated here.</p>
                    )}
                </div>
            );
        };

        const Viewer3D = ({ mesh }) => {
            // Check if controls are available before trying to use them
            if (typeof OrbitControls === 'undefined') {
                return (
                    <div className="border border-red-400 rounded-lg bg-red-50 dark:bg-red-900 flex items-center justify-center h-[300px] lg:h-[400px] relative">
                        <p className="text-red-700 dark:text-red-300 p-4 text-center">
                            3D Viewer Error: Three.js OrbitControls failed to load. Please check your browser console for CDN issues.
                        </p>
                    </div>
                );
            }

            const mountRef = useRef(null);
            const sceneRef = useRef(null);
            const cameraRef = useRef(null);
            const rendererRef = useRef(null);
            const controlsRef = useRef(null);
            const meshObjectRef = useRef(null);
            const animateIdRef = useRef(0);

            const animate = useCallback(() => {
                animateIdRef.current = requestAnimationFrame(animate);
                if (controlsRef.current) controlsRef.current.update();
                if (rendererRef.current && sceneRef.current && cameraRef.current) {
                    rendererRef.current.render(sceneRef.current, cameraRef.current);
                }
            }, []);

            useEffect(() => {
                if (!mountRef.current) return;

                const width = mountRef.current.clientWidth;
                const height = mountRef.current.clientHeight;

                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xdddddd); 
                sceneRef.current = scene;

                const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                camera.position.z = 2;
                cameraRef.current = camera;

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                mountRef.current.appendChild(renderer.domElement);
                rendererRef.current = renderer;

                scene.add(new THREE.AmbientLight(0x404040, 5));
                const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
                directionalLight.position.set(1, 1, 1).normalize();
                scene.add(directionalLight);

                const controls = new OrbitControls(camera, renderer.domElement); 
                controls.enableDamping = true; controls.dampingFactor = 0.25; controls.minDistance = 0.5; controlsRef.current = controls;

                const handleResize = () => {
                    if (cameraRef.current && rendererRef.current && mountRef.current) {
                        cameraRef.current.aspect = mountRef.current.clientWidth / mountRef.current.clientHeight;
                        cameraRef.current.updateProjectionMatrix();
                        rendererRef.current.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
                    }
                };
                window.addEventListener('resize', handleResize);
                animate();

                return () => {
                    cancelAnimationFrame(animateIdRef.current);
                    window.removeEventListener('resize', handleResize);
                    if (mountRef.current && renderer.domElement) mountRef.current.removeChild(renderer.domElement);
                    renderer.dispose(); controls.dispose();
                };
            }, [animate]);

            useEffect(() => {
                const scene = sceneRef.current;
                const camera = cameraRef.current;
                const controls = controlsRef.current;

                if (!scene || !camera || !controls) return;
                
                // Clear previous mesh
                if (meshObjectRef.current) {
                    scene.remove(meshObjectRef.current);
                    meshObjectRef.current.geometry.dispose();
                    if (Array.isArray(meshObjectRef.current.material)) meshObjectOfRef.current.material.forEach(m => m.dispose());
                    else meshObjectRef.current.material.dispose();
                    meshObjectRef.current = null;
                }

                if (!mesh) return; 

                // Create and Add New Mesh
                const material = new THREE.MeshLambertMaterial({ color: 0xcccccc, side: THREE.DoubleSide, vertexColors: false }); 
                const newMeshObject = new THREE.Mesh(mesh, material);
                scene.add(newMeshObject);
                meshObjectRef.current = newMeshObject;

                // Recenter Camera
                const box = new THREE.Box3().setFromObject(newMeshObject);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());
                newMeshObject.position.sub(center); controls.target.copy(newMeshObject.position);
                const maxDim = Math.max(size.x, size.y, size.z);
                const newDistance = maxDim * 1.5;
                camera.position.set(0, 0, newDistance);
                camera.updateProjectionMatrix(); controls.update();
            }, [mesh]);

            const showPlaceholder = !mesh;
            
            return (
                <div className="border border-gray-200 rounded-lg bg-gray-100 dark:bg-gray-900 flex items-center justify-center h-[300px] lg:h-[400px] relative">
                    <div id="threejs-container" ref={mountRef} className="w-full h-full"/>
                    {showPlaceholder && (
                        <p id="viewer-placeholder" className="text-gray-500 absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 p-4 text-center">
                            Upload image and click 'Generate' to view 3D model
                        </p>
                    )}
                </div>
            );
        };


        // --- MAIN APP ---

        const App = () => {
            const [selectedImage, setSelectedImage] = useState(null);
            const [depthMap, setDepthMap] = useState(null);
            const [mesh, setMesh] = useState(null);
            const [isProcessing, setIsProcessing] = useState(false);
            const { toast } = useToast();

            const depthEstimator = new DepthEstimator();
            const meshGenerator = new MeshGenerator();

            const handleImageSelect = useCallback((file) => {
                if (!file) {
                    setSelectedImage(null); setDepthMap(null); setMesh(null); return;
                }
                const reader = new FileReader();
                reader.onload = (e) => { setSelectedImage(e.target.result); setDepthMap(null); setMesh(null); };
                reader.readAsDataURL(file);
            }, []);

            const handleGenerate = async () => {
                if (!selectedImage) {
                    toast({ title: "No image selected", description: "Please upload an image first", variant: "destructive", }); return;
                }

                setIsProcessing(true);
                try {
                    const img = new Image();
                    img.src = selectedImage;
                    await new Promise((resolve, reject) => { img.onload = resolve; img.onerror = reject; });

                    toast({ title: "Processing image", description: "Estimating depth map...", });
                    const estimatedDepth = await depthEstimator.estimateDepth(img);
                    setDepthMap(estimatedDepth);

                    toast({ title: "Generating 3D model", description: "Creating mesh from depth data...", });
                    const generatedMesh = meshGenerator.generateMeshFromDepth(estimatedDepth);
                    setMesh(generatedMesh);

                    toast({ title: "Success!", description: "3D model generated successfully", });
                } catch (error) {
                    console.error('Generation error:', error);
                    toast({ title: "Generation failed", description: "An unknown error occurred", variant: "destructive", });
                } finally {
                    setIsProcessing(false);
                }
            };

            const handleExport = () => {
                if (!mesh) {
                    toast({ title: "No model to export", description: "Please generate a 3D model first", variant: "destructive", }); return;
                }
                try {
                    const objContent = meshGenerator.exportToOBJ(mesh);
                    meshGenerator.downloadOBJ(objContent);
                    toast({ title: "Export successful", description: "OBJ file downloaded", });
                } catch (error) {
                    toast({ title: "Export failed", description: "Failed to export the model", variant: "destructive", });
                }
            };

            return (
                <div className="min-h-screen bg-white dark:bg-gray-900 py-8 px-4">
                    <div className="max-w-7xl mx-auto">
                        <div className="text-center mb-12">
                            <div className="flex items-center justify-center gap-3 mb-4">
                                <Box className="w-10 h-10 text-blue-600" />
                                <h1 className="text-4xl font-extrabold text-gray-900 dark:text-white">
                                    AI 3D Model Generator
                                </h1>
                            </div>
                            <p className="text-gray-500 text-lg">
                                Transform 2D images into 3D models â€¢ 100% Client-Side â€¢ No Server Required
                            </p>
                        </div>

                        <div className="grid lg:grid-cols-2 gap-6 mb-8">
                            <Card className="p-6 space-y-6">
                                <div>
                                    <h2 className="text-xl font-semibold mb-4 flex items-center gap-2 text-gray-700 dark:text-gray-200">
                                        <span className="text-blue-600">1.</span> Upload Image
                                    </h2>
                                    <ImageUpload
                                        onImageSelect={handleImageSelect}
                                        selectedImage={selectedImage}
                                        isProcessing={isProcessing}
                                    />
                                </div>
                                <div>
                                    <h2 className="text-xl font-semibold mb-4 flex items-center gap-2 text-gray-700 dark:text-gray-200">
                                        <span className="text-blue-600">2.</span> Depth Map
                                    </h2>
                                    <DepthMapViewer depthMap={depthMap} />
                                </div>
                            </Card>

                            <Card className="p-6 space-y-6">
                                <div>
                                    <h2 className="text-xl font-semibold mb-4 flex items-center gap-2 text-gray-700 dark:text-gray-200">
                                        <span className="text-blue-600">3.</span> 3D Model Viewer
                                    </h2>
                                    <Viewer3D mesh={mesh} />
                                </div>

                                <div className="space-y-3">
                                    <Button
                                        onClick={handleGenerate}
                                        disabled={!selectedImage || isProcessing}
                                        className={cn("w-full h-12 text-base", isProcessing ? "opacity-70 cursor-not-allowed" : "")}
                                    >
                                        {isProcessing ? (
                                            <>
                                                <Loader2 className="w-5 h-5 mr-2 animate-spin" />
                                                Processing...
                                            </>
                                        ) : (
                                            <>
                                                <Box className="w-5 h-5 mr-2" />
                                                Generate 3D Model
                                            </>
                                        )}
                                    </Button>

                                    <Button
                                        onClick={handleExport}
                                        disabled={!mesh || isProcessing}
                                        variant="outline"
                                        className="w-full h-12 text-base border-gray-300 dark:border-gray-700 text-gray-700 dark:text-gray-200 hover:bg-gray-50 dark:hover:bg-gray-700"
                                    >
                                        <Download className="w-5 h-5 mr-2" />
                                        Download OBJ
                                    </Button>
                                </div>
                            </Card>
                        </div>

                        <div className="grid md:grid-cols-3 gap-4">
                            <Card className="p-4 bg-gray-50 dark:bg-gray-800 border-blue-200 dark:border-blue-800">
                                <h3 className="font-semibold text-blue-600 mb-2">ðŸ”’ Privacy First</h3>
                                <p className="text-sm text-gray-600 dark:text-gray-400">All processing happens locally in your browser. No data is uploaded to any server.</p>
                            </Card>
                            <Card className="p-4 bg-gray-50 dark:bg-gray-800 border-blue-200 dark:border-blue-800">
                                <h3 className="font-semibold text-blue-600 mb-2">âš¡ WebGL Accelerated</h3>
                                <p className="text-sm text-gray-600 dark:text-gray-400">Powered by Three.js and browser APIs for fast, client-side performance.</p>
                            </Card>
                            <Card className="p-4 bg-gray-50 dark:bg-gray-800 border-blue-200 dark:border-blue-800">
                                <h3 className="font-semibold text-blue-600 mb-2">ðŸ“¦ Export Ready</h3>
                                <p className="text-sm text-gray-600 dark:text-gray-400">Export to OBJ format compatible with Blender, Unity, and other 3D tools.</p>
                            </Card>
                        </div>
                    </div>
                    <MockToastContainer />
                </div>
            );
        };

        // Start the application
        const rootElement = document.getElementById('root');
        if (rootElement) {
            ReactDOM.createRoot(rootElement).render(<App />);
        }
    </script>
</body>
</html>
