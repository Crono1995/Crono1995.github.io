<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 3D Model Generator</title>
    <style>
        :root { --bg: #0d1117; --card: #161b22; --border: #30363d; --blue: #58a6ff; --gray: #8b949e; }
        * { box-sizing: border-box; margin:0; padding:0; }
        body { background:var(--bg); color:white; font-family:system-ui; min-height:100vh; padding:2rem; }
        .container { max-width:1200px; margin:auto; }
        h1 { font-size:3rem; background:linear-gradient(to right,#58a6ff,#89c4f4); -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text; text-align:center; margin-bottom:1rem; }
        p { color:var(--gray); text-align:center; margin-bottom:2rem; }
        .grid { display:grid; grid-template-columns:1fr 1fr; gap:2rem; }
        .card { background:var(--card); border:1px solid var(--border); border-radius:12px; padding:1.5rem; }
        .upload { border:2px dashed #525252; border-radius:12px; padding:3rem; text-align:center; cursor:pointer; transition:border-color 0.3s; }
        .upload:hover { border-color:var(--blue); }
        .btn { width:100%; padding:1rem; border:none; border-radius:8px; font-weight:600; cursor:pointer; margin-top:1rem; transition:opacity 0.3s; }
        .btn-primary { background:linear-gradient(to right,#58a6ff,#89c4f4); color:white; }
        .btn-primary:disabled { opacity:0.5; cursor:not-allowed; }
        .btn-secondary { background:transparent; border:1px solid var(--blue); color:white; }
        .btn-secondary:hover:not(:disabled) { background:rgba(88,166,255,0.1); }
        #viewer3d-container, #depth-map-container { height:420px; border-radius:12px; background:#010409; overflow:hidden; margin-top:1rem; display:flex; align-items:center; justify-content:center; color:var(--gray); }
        #loading { border:4px solid #ffffff30; border-top:4px solid #58a6ff; border-radius:50%; width:24px; height:24px; animation:spin 1s linear infinite; display:inline-block; margin-right:8px; }
        @keyframes spin { to { transform:rotate(360deg); } }
        .toast { position:fixed; top:1rem; right:1rem; padding:1rem 1.5rem; border-radius:8px; color:white; z-index:9999; animation:slideIn 0.3s; }
        @keyframes slideIn { from { transform:translateX(100%); opacity:0; } to { transform:translateX(0); opacity:1; } }
        .success { background:#16a34a; } .error { background:#dc2626; }
        .slider-container { margin-top:1rem; }
        .slider { width:100%; }
        label { color:var(--gray); font-size:0.9rem; display:block; margin-bottom:0.5rem; }
        @media (max-width:1024px) { .grid { grid-template-columns:1fr; } }
    </style>
</head>
<body>
    <div class="container">
        <h1>AI 3D Model Generator</h1>
        <p>100% Client-Side â€¢ Works Offline â€¢ No Data Leaves Your Browser</p>

        <div class="grid">
            <div>
                <div class="card">
                    <h2 style="color:var(--blue);margin-bottom:1rem;">1. Upload Image</h2>
                    <div class="upload" onclick="document.getElementById('file').click()">
                        <input type="file" id="file" accept="image/*" style="display:none">
                        <p style="color:var(--blue);font-size:1.2rem;">ðŸ“· Click to upload</p>
                        <img id="preview" style="max-height:250px;margin-top:1rem;border-radius:8px;display:none;">
                    </div>
                </div>

                <div class="card">
                    <h2 style="color:var(--blue);margin-bottom:1rem;">2. Depth Map</h2>
                    <div id="depth-map-container">Depth map will appear here...</div>
                    
                    <div class="slider-container">
                        <label for="depth-intensity">Depth Intensity: <span id="depth-value">1.0</span></label>
                        <input type="range" id="depth-intensity" class="slider" min="0.1" max="3" step="0.1" value="1.0">
                    </div>
                </div>
            </div>

            <div>
                <div class="card">
                    <h2 style="color:var(--blue);margin-bottom:1rem;">3. 3D Model</h2>
                    <div id="viewer3d-container">3D model will appear here...</div>
                </div>

                <div class="card">
                    <button id="generate" class="btn btn-primary">
                        <span id="loading" style="display:none;"></span>
                        <span id="btn-text">Generate 3D Model</span>
                    </button>
                    <button id="download" class="btn btn-secondary" disabled>Download OBJ</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let imageElement = null;
        let geometry = null;
        let currentDepthData = null;
        let mesh = null;

        // Toast notification
        function toast(msg, error = false) {
            const t = document.createElement('div');
            t.className = `toast ${error?'error':'success'}`;
            t.textContent = msg;
            document.body.appendChild(t);
            setTimeout(() => t.remove(), 3000);
        }

        // Wait for DOM to be fully loaded
        window.addEventListener('DOMContentLoaded', () => {
            console.log('Initializing 3D Model Generator...');

            // ===== 3D VIEWER SETUP =====
            const viewerContainer = document.getElementById('viewer3d-container');
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x010409);
            
            const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 100);
            camera.position.z = 5;
            
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(600, 420);
            viewerContainer.innerHTML = '';
            viewerContainer.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            // Model group for rotation
            const group = new THREE.Group();
            scene.add(group);

            // Mouse controls for rotation
            let dragging = false;
            let prevMouse = {x: 0, y: 0};
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                dragging = true;
                prevMouse = {x: e.clientX, y: e.clientY};
            });
            
            document.addEventListener('mouseup', () => {
                dragging = false;
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!dragging) return;
                const deltaX = e.clientX - prevMouse.x;
                const deltaY = e.clientY - prevMouse.y;
                group.rotation.y += deltaX * 0.01;
                group.rotation.x += deltaY * 0.01;
                prevMouse = {x: e.clientX, y: e.clientY};
            });

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }
            animate();

            // ===== DEPTH INTENSITY SLIDER =====
            document.getElementById('depth-intensity').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('depth-value').textContent = value.toFixed(1);
                
                if (currentDepthData && imageElement) {
                    updateDepthModel(value);
                }
            });

            // ===== GENERATE DEPTH MAP (CLIENT-SIDE ALGORITHM) =====
            function generateDepthMap(img) {
                const canvas = document.createElement('canvas');
                const size = 256;
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                // Draw image
                ctx.drawImage(img, 0, 0, size, size);
                const imageData = ctx.getImageData(0, 0, size, size);
                const data = imageData.data;
                
                // Create depth data based on luminance + edge detection
                const depthData = new Float32Array(size * size);
                
                // Calculate luminance and edges
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        const i = (y * size + x) * 4;
                        const idx = y * size + x;
                        
                        // Luminance (brighter = closer)
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                        
                        // Edge detection (Sobel-like)
                        let edgeStrength = 0;
                        if (x > 0 && x < size - 1 && y > 0 && y < size - 1) {
                            const getGray = (dx, dy) => {
                                const i = ((y + dy) * size + (x + dx)) * 4;
                                return (data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114) / 255;
                            };
                            
                            const gx = getGray(1, 0) - getGray(-1, 0);
                            const gy = getGray(0, 1) - getGray(0, -1);
                            edgeStrength = Math.sqrt(gx * gx + gy * gy);
                        }
                        
                        // Combine luminance with edge information
                        // Brighter areas and edges are considered closer
                        depthData[idx] = luminance * 0.7 + edgeStrength * 0.3;
                    }
                }
                
                // Apply Gaussian blur for smoothing
                const blurred = gaussianBlur(depthData, size, size, 2);
                
                // Normalize
                let min = Infinity, max = -Infinity;
                for (let i = 0; i < blurred.length; i++) {
                    if (blurred[i] < min) min = blurred[i];
                    if (blurred[i] > max) max = blurred[i];
                }
                const range = max - min || 1;
                for (let i = 0; i < blurred.length; i++) {
                    blurred[i] = (blurred[i] - min) / range;
                }
                
                return { data: blurred, width: size, height: size };
            }

            // Simple Gaussian blur
            function gaussianBlur(data, width, height, radius) {
                const output = new Float32Array(data.length);
                const kernel = [];
                const sigma = radius / 3;
                let sum = 0;
                
                for (let i = -radius; i <= radius; i++) {
                    const val = Math.exp(-(i * i) / (2 * sigma * sigma));
                    kernel.push(val);
                    sum += val;
                }
                
                for (let i = 0; i < kernel.length; i++) {
                    kernel[i] /= sum;
                }
                
                // Horizontal pass
                const temp = new Float32Array(data.length);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let val = 0;
                        for (let i = -radius; i <= radius; i++) {
                            const xi = Math.max(0, Math.min(width - 1, x + i));
                            val += data[y * width + xi] * kernel[i + radius];
                        }
                        temp[y * width + x] = val;
                    }
                }
                
                // Vertical pass
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let val = 0;
                        for (let i = -radius; i <= radius; i++) {
                            const yi = Math.max(0, Math.min(height - 1, y + i));
                            val += temp[yi * width + x] * kernel[i + radius];
                        }
                        output[y * width + x] = val;
                    }
                }
                
                return output;
            }

            // ===== VISUALIZE DEPTH MAP =====
            function visualizeDepthMap(depthMap) {
                const { data, width, height } = depthMap;
                
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                
                const imageData = ctx.createImageData(width, height);
                const pixels = imageData.data;
                
                for (let i = 0; i < data.length; i++) {
                    const grayValue = Math.floor((1 - data[i]) * 255);
                    pixels[i * 4] = grayValue;
                    pixels[i * 4 + 1] = grayValue;
                    pixels[i * 4 + 2] = grayValue;
                    pixels[i * 4 + 3] = 255;
                }
                
                ctx.putImageData(imageData, 0, 0);
                
                const container = document.getElementById('depth-map-container');
                container.innerHTML = '';
                canvas.style.maxWidth = '100%';
                canvas.style.maxHeight = '100%';
                canvas.style.objectFit = 'contain';
                container.appendChild(canvas);
            }

            // ===== CREATE 3D GEOMETRY =====
            function createGeometry(depthMap, intensity = 1.0) {
                const { data, width, height } = depthMap;
                const geo = new THREE.BufferGeometry();
                const vertices = [];
                const uvs = [];
                const indices = [];

                // Create vertices
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = y * width + x;
                        const depth = data[i];
                        
                        const xPos = (x / width - 0.5) * 5;
                        const yPos = (0.5 - y / height) * 5;
                        const zPos = -depth * 2.5 * intensity;
                        
                        vertices.push(xPos, yPos, zPos);
                        uvs.push(x / width, 1 - y / height);
                    }
                }

                // Create triangles
                for (let y = 0; y < height - 1; y++) {
                    for (let x = 0; x < width - 1; x++) {
                        const i = y * width + x;
                        indices.push(i, i + 1, i + width);
                        indices.push(i + 1, i + width + 1, i + width);
                    }
                }

                geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geo.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
                geo.setIndex(indices);
                geo.computeVertexNormals();

                return geo;
            }

            // ===== UPDATE DEPTH MODEL =====
            function updateDepthModel(intensity) {
                if (!currentDepthData || !imageElement) return;
                
                // Remove old mesh
                if (mesh) {
                    group.remove(mesh);
                    if (geometry) geometry.dispose();
                }
                
                // Create new geometry with updated intensity
                geometry = createGeometry(currentDepthData, intensity);
                
                const texture = new THREE.TextureLoader().load(imageElement.src);
                texture.colorSpace = THREE.SRGBColorSpace;
                
                const material = new THREE.MeshPhongMaterial({ 
                    map: texture, 
                    side: THREE.DoubleSide,
                    flatShading: false
                });
                
                mesh = new THREE.Mesh(geometry, material);
                group.add(mesh);
                
                // Center the model
                geometry.computeBoundingBox();
                const center = new THREE.Vector3();
                geometry.boundingBox.getCenter(center);
                group.position.sub(center);
            }

            // ===== GENERATE 3D MODEL =====
            document.getElementById('generate').onclick = async () => {
                if (!imageElement) {
                    toast('Please upload an image first', true);
                    return;
                }

                const loadingSpinner = document.getElementById('loading');
                const btnText = document.getElementById('btn-text');
                
                loadingSpinner.style.display = 'inline-block';
                btnText.textContent = 'Processing...';

                try {
                    console.log('Generating depth map...');
                    
                    // Generate depth map
                    currentDepthData = generateDepthMap(imageElement);
                    
                    // Visualize depth map
                    visualizeDepthMap(currentDepthData);
                    
                    // Get current intensity
                    const intensity = parseFloat(document.getElementById('depth-intensity').value);
                    
                    // Create 3D model
                    updateDepthModel(intensity);
                    
                    document.getElementById('download').disabled = false;
                    toast('3D Model Ready!');
                    console.log('3D model generated successfully');
                    
                } catch (error) {
                    console.error('Generation error:', error);
                    toast('Error: ' + error.message, true);
                } finally {
                    loadingSpinner.style.display = 'none';
                    btnText.textContent = 'Generate 3D Model';
                }
            };

            // ===== DOWNLOAD OBJ =====
            document.getElementById('download').onclick = () => {
                if (!geometry) {
                    toast('No model to download', true);
                    return;
                }

                try {
                    const pos = geometry.attributes.position.array;
                    const uv = geometry.attributes.uv.array;
                    const idx = geometry.index.array;
                    
                    let obj = '# OBJ file generated by AI 3D Model Generator\n';
                    obj += 'o Model\n\n';
                    
                    obj += '# Vertices\n';
                    for (let i = 0; i < pos.length; i += 3) {
                        obj += `v ${pos[i].toFixed(6)} ${pos[i + 1].toFixed(6)} ${pos[i + 2].toFixed(6)}\n`;
                    }
                    
                    obj += '\n# Texture coordinates\n';
                    for (let i = 0; i < uv.length; i += 2) {
                        obj += `vt ${uv[i].toFixed(6)} ${uv[i + 1].toFixed(6)}\n`;
                    }
                    
                    obj += '\n# Faces\n';
                    for (let i = 0; i < idx.length; i += 3) {
                        const i1 = idx[i] + 1;
                        const i2 = idx[i + 1] + 1;
                        const i3 = idx[i + 2] + 1;
                        obj += `f ${i1}/${i1} ${i2}/${i2} ${i3}/${i3}\n`;
                    }

                    const blob = new Blob([obj], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = '3d-model.obj';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    toast('OBJ file downloaded!');
                } catch (error) {
                    console.error('Download error:', error);
                    toast('Download failed: ' + error.message, true);
                }
            };

            // ===== FILE UPLOAD =====
            document.getElementById('file').onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.onload = () => {
                        const preview = document.getElementById('preview');
                        preview.src = img.src;
                        preview.style.display = 'block';
                        
                        imageElement = img;
                        toast('Image ready â€“ click Generate!');
                        console.log('Image loaded:', img.width, 'x', img.height);
                    };
                    
                    img.onerror = () => {
                        toast('Failed to load image', true);
                    };
                    
                    img.src = ev.target.result;
                };
                
                reader.onerror = () => {
                    toast('Failed to read file', true);
                };
                
                reader.readAsDataURL(file);
            };

            toast('Ready! Upload an image to begin');
        });
    </script>
</body>
</html>
