<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>AI 3D Model Generator â€” Fixed</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <!-- TensorFlow.js kept but not required: removed remote model load to avoid 404; fallback-only depth estimation implemented -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.165.0/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.165.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        .text-gradient { background-image: linear-gradient(45deg,#10b981,#3b82f6); -webkit-background-clip:text; -webkit-text-fill-color:transparent }
        .gradient-primary{background-color:#3b82f6;color:white;transition:background-color .2s}
        .gradient-primary:hover:not(:disabled){background-color:#2563eb}
        .card{background-color:white;border-radius:.5rem;box-shadow:0 4px 6px -1px rgba(0,0,0,.1),0 2px 4px -2px rgba(0,0,0,.1)}
        .bg-background{background-color:#f3f4f6}
        .min-h-screen{min-height:100vh}
        .loader-spin{animation:spin 1s linear infinite}
        @keyframes spin{100%{transform:rotate(360deg)}}
        #toast-container{position:fixed;top:1rem;right:1rem;z-index:1000}
        .toast{margin-top:.5rem;padding:1rem;border-radius:.375rem;color:white;box-shadow:0 10px 15px -3px rgba(0,0,0,.1),0 4px 6px -4px rgba(0,0,0,.1);transition:opacity .3s ease-out}
        .toast.destructive{background-color:#ef4444}.toast.success{background-color:#10b981}.toast.info{background-color:#3b82f6}
    </style>
</head>
<body class="bg-background">
    <div id="toast-container"></div>
    <div class="min-h-screen py-8 px-4">
        <div class="max-w-7xl mx-auto">
            <div class="text-center mb-12">
                <div class="flex items-center justify-center gap-3 mb-4">
                    <i data-lucide="box" class="w-10 h-10 text-[#3b82f6]"></i>
                    <h1 class="text-5xl font-bold text-gradient">AI 3D Model Generator (Fixed)</h1>
                </div>
                <p class="text-gray-500 text-lg">Client-only depth approximation + robust mesh export. No remote model required.</p>
            </div>

            <div class="grid lg:grid-cols-2 gap-6 mb-8">
                <div class="card p-6 space-y-6">
                    <div>
                        <h2 class="text-xl font-semibold mb-4 flex items-center gap-2"><span class="text-[#3b82f6]">1.</span> Upload Image</h2>
                        <div class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center hover:border-[#3b82f6] transition cursor-pointer">
                            <input type="file" id="image-upload-input" accept="image/*" class="hidden">
                            <label for="image-upload-input" id="upload-label" class="block cursor-pointer">
                                <i data-lucide="image" class="w-8 h-8 mx-auto text-gray-400 mb-2"></i>
                                <p class="text-sm text-gray-600">Click to upload or drag and drop</p>
                                <p class="text-xs text-gray-500">PNG, JPG, up to 10MB</p>
                            </label>
                            <img id="selected-image-preview" class="mt-4 hidden max-h-64 object-contain mx-auto" src="" alt="Selected Image">
                        </div>
                    </div>

                    <div>
                        <h2 class="text-xl font-semibold mb-4 flex items-center gap-2"><span class="text-[#3b82f6]">2.</span> Depth Map</h2>
                        <div id="depth-map-container" class="border border-gray-200 rounded-lg bg-gray-100 flex items-center justify-center h-64 overflow-hidden">
                            <p id="depth-map-placeholder" class="text-gray-500">Depth Map will appear here</p>
                            <canvas id="depth-map-canvas" class="hidden max-w-full max-h-full"></canvas>
                        </div>
                    </div>

                    <div id="model-loading-container" class="space-y-2 pt-6 hidden">
                        <h3 class="text-sm font-medium text-gray-700 flex items-center gap-2">
                            <i data-lucide="download-cloud" class="w-4 h-4 text-[#3b82f6]"></i>
                            Model status:
                            <span id="model-progress-text" class="font-bold">Ready</span>
                        </h3>
                    </div>
                </div>

                <div class="card p-6 space-y-6">
                    <div>
                        <h2 class="text-xl font-semibold mb-4 flex items-center gap-2"><span class="text-[#3b82f6]">3.</span> 3D Model Viewer</h2>
                        <div id="viewer-3d-container" class="border border-gray-200 rounded-lg bg-gray-100 flex items-center justify-center h-64 relative">
                            <div id="threejs-container" class="w-full h-full"></div>
                            <p id="viewer-placeholder" class="text-gray-500 absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2">3D Model will appear here</p>
                            <div id="viewer-loading-bar" class="absolute inset-0 bg-gray-800 bg-opacity-70 flex flex-col items-center justify-center hidden">
                                <i data-lucide="loader-2" class="w-8 h-8 text-white loader-spin mb-3"></i>
                                <p class="text-white font-semibold">Generating 3D Mesh...</p>
                            </div>
                        </div>
                    </div>

                    <div class="space-y-3">
                        <button id="generate-button" disabled class="w-full h-12 text-base gradient-primary transition-opacity flex items-center justify-center rounded-lg disabled:opacity-50">
                            <i data-lucide="box" class="w-5 h-5 mr-2"></i>
                            <span id="generate-text">Generate 3D Model</span>
                        </button>

                        <button id="export-button" disabled class="w-full h-12 text-base border border-gray-300 text-gray-700 hover:bg-gray-100 transition flex items-center justify-center rounded-lg disabled:opacity-50">
                            <i data-lucide="download" class="w-5 h-5 mr-2"></i>
                            Download OBJ
                        </button>
                    </div>
                </div>
            </div>

            <div class="grid md:grid-cols-3 gap-4">
                <div class="card p-4 bg-gray-50 border border-gray-200">
                    <h3 class="font-semibold text-[#3b82f6] mb-2">ðŸ”’ Privacy First</h3>
                    <p class="text-sm text-gray-500">All processing happens locally in your browser. No data is uploaded to any server.</p>
                </div>
                <div class="card p-4 bg-gray-50 border border-gray-200">
                    <h3 class="font-semibold text-[#3b82f6] mb-2">âš¡ WebGL Accelerated</h3>
                    <p class="text-sm text-gray-500">Powered by Three.js for fast rendering.</p>
                </div>
                <div class="card p-4 bg-gray-50 border border-gray-200">
                    <h3 class="font-semibold text-[#3b82f6] mb-2">ðŸ“¦ Export Ready</h3>
                    <p class="text-sm text-gray-500">Export to OBJ format compatible with Blender, Unity, and other 3D tools.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- GLOBAL STATE ---
        let selectedImageBase64 = null;
        let depthMapImageData = null;
        let generatedMesh = null;
        let isProcessing = false;

        // --- ELEMENTS ---
        const imageInput = document.getElementById('image-upload-input');
        const imagePreview = document.getElementById('selected-image-preview');
        const uploadLabel = document.getElementById('upload-label');
        const generateButton = document.getElementById('generate-button');
        const exportButton = document.getElementById('export-button');
        const depthMapCanvas = document.getElementById('depth-map-canvas');
        const depthMapPlaceholder = document.getElementById('depth-map-placeholder');
        const viewerContainer = document.getElementById('threejs-container');
        const viewerPlaceholder = document.getElementById('viewer-placeholder');
        const viewerLoadingBar = document.getElementById('viewer-loading-bar');

        const modelLoadingContainer = document.getElementById('model-loading-container');
        const modelProgressText = document.getElementById('model-progress-text');

        // --- UTILS ---
        function showToast({ title, description, variant = 'info' }) {
            const toastDiv = document.createElement('div');
            toastDiv.className = `toast ${variant} max-w-sm`;
            toastDiv.innerHTML = `<div class="font-bold">${title}</div><p class="text-sm">${description}</p>`;
            document.getElementById('toast-container').appendChild(toastDiv);
            setTimeout(() => { toastDiv.style.opacity = '0'; setTimeout(() => toastDiv.remove(), 300); }, 4500);
        }

        function waitForLibrary(libName) {
            return new Promise((resolve) => {
                const check = () => {
                    if (libName === 'THREE') {
                        if (typeof THREE !== 'undefined') return resolve();
                    } else if (libName === 'lucide') {
                        if (typeof lucide !== 'undefined') return resolve();
                    } else if (libName === 'tf') {
                        if (typeof tf !== 'undefined') return resolve();
                    }
                    setTimeout(check, 80);
                };
                check();
            });
        }

        // --- IMAGE UPLOAD ---
        imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                selectedImageBase64 = ev.target.result;
                imagePreview.src = selectedImageBase64;
                imagePreview.classList.remove('hidden');
                uploadLabel.classList.add('hidden');

                depthMapImageData = null; generatedMesh = null;
                clearDepthMap(); clear3DViewer();

                generateButton.disabled = false; exportButton.disabled = true;
                showToast({ title: 'Image Uploaded', description: "Click 'Generate 3D Model' to begin processing.", variant: 'success' });
            };
            reader.readAsDataURL(file);
        });

        // --- DEPTH ESTIMATOR (FALLBACK-ONLY FOR STABILITY) ---
        class DepthEstimator {
            constructor() { this.model = null; this.inputSize = 256; }

            async loadModel() {
                // Instead of loading a remote TFJS MiDaS model (which many hosts return 404),
                // we always use a robust client-side fallback. Keep this function for compatibility.
                this.model = 'fallback';
                modelLoadingContainer.classList.add('hidden');
                modelProgressText.textContent = 'Using local approximation';
                return this.model;
            }

            async estimateDepth(image) {
                await this.loadModel();
                // If a graph model existed we'd call it here â€” but to guarantee operation we run a reliable JS approximation.
                return this.fallbackDepthEstimation(image);
            }

            fallbackDepthEstimation(image) {
                // Simple luminance + vertical bias + small blur to approximate depth.
                const w = image.width, h = image.height;
                const canvas = document.createElement('canvas');
                canvas.width = w; canvas.height = h;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(image, 0, 0, w, h);
                const imgData = ctx.getImageData(0, 0, w, h);
                const data = imgData.data;
                const out = new Uint8ClampedArray(w * h * 4);

                // convert to luminance and add soft vertical gradient to simulate depth
                for (let y = 0; y < h; y++) {
                    const vBias = (1 - (y / (h - 1))) * 0.35; // boost top-to-bottom or bottom-to-top as needed
                    for (let x = 0; x < w; x++) {
                        const i = (y * w + x) * 4;
                        const r = data[i], g = data[i + 1], b = data[i + 2];
                        const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                        // invert luminance so darker -> farther (optional tweak)
                        let depthVal = (255 - lum) * 0.8 + (vBias * 255);
                        depthVal = Math.max(0, Math.min(255, Math.round(depthVal)));
                        out[i] = out[i + 1] = out[i + 2] = depthVal;
                        out[i + 3] = 255;
                    }
                }

                // Optional: small box blur pass to smooth the result (1-pass)
                const blurred = new Uint8ClampedArray(out.length);
                const kernel = [1,2,1,2,4,2,1,2,1];
                const ksum = 16;
                for (let y = 1; y < h-1; y++) {
                    for (let x = 1; x < w-1; x++) {
                        let s = 0; let idx = 0;
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const ii = ((y+ky) * w + (x+kx)) * 4;
                                s += out[ii] * kernel[idx++];
                            }
                        }
                        const di = (y * w + x) * 4;
                        const v = Math.round(s / ksum);
                        blurred[di] = blurred[di+1] = blurred[di+2] = v;
                        blurred[di+3] = 255;
                    }
                }

                // copy edges and corners from original out if blur not written there
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        const i = (y * w + x) * 4;
                        if (x === 0 || y === 0 || x === w-1 || y === h-1) {
                            blurred[i] = out[i]; blurred[i+1] = out[i+1]; blurred[i+2] = out[i+2]; blurred[i+3] = out[i+3];
                        }
                    }
                }

                return new ImageData(blurred, w, h);
            }
        }

        // --- DEPTH MAP VIEWER ---
        function clearDepthMap() {
            depthMapCanvas.classList.add('hidden');
            depthMapPlaceholder.classList.remove('hidden');
            depthMapCanvas.width = 0; depthMapCanvas.height = 0;
        }

        function displayDepthMap(imageData) {
            depthMapCanvas.width = imageData.width; depthMapCanvas.height = imageData.height;
            const ctx = depthMapCanvas.getContext('2d');
            ctx.putImageData(imageData, 0, 0);
            depthMapCanvas.style.width = 'auto'; depthMapCanvas.style.height = '100%';
            depthMapCanvas.classList.remove('hidden'); depthMapPlaceholder.classList.add('hidden');
        }

        // --- MESH GENERATOR ---
        class MeshGenerator {
            generateMeshFromDepth(imageData) {
                if (typeof THREE === 'undefined') return null;
                const { data, width, height } = imageData;

                const MAX_PIXELS = 1024 * 1024;
                if (width * height > MAX_PIXELS) throw new Error(`Input too large (${width}x${height}). Resize image to <= 1024x1024 for export.`);

                if (!data || data.length === 0) return null;

                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const uvs = [];
                const indices = [];
                const depthScale = 0.5;
                const aspect = width / height;

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        const norm = data[i] / 255.0;
                        const vx = (x / (width - 1) - 0.5) * aspect;
                        const vy = (0.5 - y / (height - 1));
                        const vz = norm * depthScale;
                        vertices.push(vx, vy, vz);
                        uvs.push(x / (width - 1), 1 - y / (height - 1));
                    }
                }

                for (let y = 0; y < height - 1; y++) {
                    for (let x = 0; x < width - 1; x++) {
                        const i = y * width + x;
                        const iR = i + 1;
                        const iD = i + width;
                        const iDR = iD + 1;
                        indices.push(i, iD, iR);
                        indices.push(iR, iD, iDR);
                    }
                }

                geometry.setIndex(indices);
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
                geometry.computeVertexNormals();
                return geometry;
            }

            exportToOBJ(geometry) {
                const vertices = geometry.getAttribute('position').array;
                const indices = geometry.getIndex().array;
                let obj = '# OBJ file generated from Depth Map\n';
                for (let i = 0; i < vertices.length; i += 3) obj += `v ${vertices[i]} ${vertices[i+1]} ${vertices[i+2]}\n`;
                for (let i = 0; i < indices.length; i += 3) {
                    const a = indices[i] + 1; const b = indices[i+1] + 1; const c = indices[i+2] + 1;
                    obj += `f ${a} ${b} ${c}\n`;
                }
                return obj;
            }

            downloadOBJ(content) {
                const blob = new Blob([content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = '3d_model.obj';
                document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
            }
        }

        // --- THREE.JS VIEWER ---
        let scene, camera, renderer, controls, meshObject;

        async function init3DViewer() {
            await waitForLibrary('THREE');
            if (scene) return;
            scene = new THREE.Scene(); scene.background = new THREE.Color(0xf0f0f0);
            camera = new THREE.PerspectiveCamera(60, viewerContainer.clientWidth / viewerContainer.clientHeight, 0.01, 1000);
            camera.position.z = 2;
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio || 1);
            renderer.setSize(viewerContainer.clientWidth, viewerContainer.clientHeight);
            viewerContainer.innerHTML = ''; viewerContainer.appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0x404040, 5); scene.add(ambient);
            const dir = new THREE.DirectionalLight(0xffffff, 3); dir.position.set(1,1,1).normalize(); scene.add(dir);

            if (THREE.OrbitControls) {
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true; controls.dampingFactor = 0.25; controls.screenSpacePanning = false; controls.minDistance = 0.2; controls.maxDistance = 10;
            }

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function onWindowResize() {
            if (!camera || !renderer) return;
            camera.aspect = viewerContainer.clientWidth / viewerContainer.clientHeight; camera.updateProjectionMatrix();
            renderer.setSize(viewerContainer.clientWidth, viewerContainer.clientHeight);
        }

        function animate() { requestAnimationFrame(animate); if (controls) controls.update(); if (renderer && scene && camera) renderer.render(scene, camera); }

        function clear3DViewer() {
            if (meshObject && scene) {
                scene.remove(meshObject);
                try { meshObject.geometry.dispose(); } catch(e){}
                try {
                    if (Array.isArray(meshObject.material)) meshObject.material.forEach(m => m.dispose()); else meshObject.material.dispose();
                } catch(e){}
                meshObject = null;
            }
            if (viewerPlaceholder) viewerPlaceholder.classList.remove('hidden');
            viewerLoadingBar.classList.add('hidden');
        }

        function startViewerLoading() { viewerLoadingBar.classList.remove('hidden'); viewerPlaceholder.classList.add('hidden'); }
        function stopViewerLoading() { viewerLoadingBar.classList.add('hidden'); }

        function displayMesh(geometry, textureImage) {
            startViewerLoading();
            const material = new THREE.MeshLambertMaterial({ side: THREE.DoubleSide });
            meshObject = new THREE.Mesh(geometry, material);
            scene.add(meshObject);

            const box = new THREE.Box3().setFromObject(meshObject);
            const size = box.getSize(new THREE.Vector3()); const center = box.getCenter(new THREE.Vector3());
            meshObject.position.sub(center);
            if (controls) controls.target.copy(meshObject.position);
            const maxDim = Math.max(size.x, size.y, size.z); const newDistance = Math.max(0.5, maxDim * 2);
            camera.position.set(0, 0, newDistance); camera.updateProjectionMatrix(); if (controls) controls.update();

            // Load texture safely (use image src)
            if (textureImage && textureImage.src) {
                new THREE.TextureLoader().load(textureImage.src,
                    (tex) => { meshObject.material.map = tex; meshObject.material.needsUpdate = true; stopViewerLoading(); exportButton.disabled = false; showToast({ title: '3D Model Ready', description: 'Use your mouse to rotate the model.', variant: 'success' }); },
                    undefined,
                    (err) => { console.warn('Texture load failed', err); stopViewerLoading(); exportButton.disabled = false; showToast({ title: 'Texture Error', description: 'Displaying untextured mesh.', variant: 'info' }); }
                );
            } else {
                stopViewerLoading(); exportButton.disabled = false; showToast({ title: '3D Model Ready', description: 'Use your mouse to rotate the model.', variant: 'success' });
            }
        }

        // --- MAIN ---
        const depthEstimator = new DepthEstimator();
        const meshGenerator = new MeshGenerator();

        generateButton.addEventListener('click', async () => {
            if (!selectedImageBase64 || isProcessing) return;
            isProcessing = true; generateButton.disabled = true; exportButton.disabled = true;
            generateButton.innerHTML = `<i data-lucide="loader-2" class="w-5 h-5 mr-2 loader-spin"></i> Processing...`;
            lucide.createIcons();

            try {
                const img = new Image(); img.crossOrigin = 'anonymous'; img.src = selectedImageBase64;
                await new Promise((res, rej) => { img.onload = res; img.onerror = rej; });

                showToast({ title: 'Processing image', description: 'Estimating depth map using client-side approximation...' });
                const estimatedDepth = await depthEstimator.estimateDepth(img);
                depthMapImageData = estimatedDepth; displayDepthMap(estimatedDepth);

                showToast({ title: 'Generating 3D model', description: 'Creating mesh from depth data...' });
                await waitForLibrary('THREE');

                const generated = meshGenerator.generateMeshFromDepth(estimatedDepth);
                if (!generated) throw new Error('Mesh generation failed.');
                generatedMesh = generated;
                displayMesh(generated, img);

            } catch (err) {
                console.error('Generation error:', err);
                stopViewerLoading(); showToast({ title: 'Generation failed', description: err.message || 'Unknown error', variant: 'destructive' });
            } finally {
                isProcessing = false; generateButton.disabled = !selectedImageBase64; generateButton.innerHTML = `<i data-lucide="box" class="w-5 h-5 mr-2"></i> <span id="generate-text">Generate 3D Model</span>`; lucide.createIcons();
            }
        });

        exportButton.addEventListener('click', () => {
            if (!generatedMesh) { showToast({ title: 'No model to export', description: 'Please generate a 3D model first', variant: 'destructive' }); return; }
            try { const obj = meshGenerator.exportToOBJ(generatedMesh); meshGenerator.downloadOBJ(obj); showToast({ title: 'Export successful', description: 'OBJ file downloaded', variant: 'success' }); }
            catch (e) { showToast({ title: 'Export failed', description: e.message, variant: 'destructive' }); }
        });

        (async function init() { await init3DViewer(); await waitForLibrary('lucide'); lucide.createIcons(); })();
    </script>
</body>
</html>
