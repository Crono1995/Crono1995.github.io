1) Add helper function to resize images (insert before the generateButton.addEventListener('click', async () => { block)

Find a place just above the // --- MAIN --- comment or any point before the generateButton listener. Insert this helper resizeImageToMax() function:

// ------------------ Insert: image resize helper ------------------
/**
 * Resize an HTMLImageElement to maxSize (preserving aspect ratio).
 * Returns a new HTMLImageElement (data URL) that is safe to process quickly.
 */
async function resizeImageToMax(img, maxSize = 1024) {
    // If already small enough, return original image
    if (img.naturalWidth <= maxSize && img.naturalHeight <= maxSize) {
        return img;
    }

    const scale = Math.min(maxSize / img.naturalWidth, maxSize / img.naturalHeight);
    const w = Math.max(1, Math.round(img.naturalWidth * scale));
    const h = Math.max(1, Math.round(img.naturalHeight * scale));

    const canvas = document.createElement('canvas');
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d');
    // draw with smoothing
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(img, 0, 0, w, h);

    const resizedImg = new Image();
    resizedImg.crossOrigin = 'anonymous';
    resizedImg.src = canvas.toDataURL('image/png');
    await new Promise((res, rej) => { resizedImg.onload = res; resizedImg.onerror = rej; });
    return resizedImg;
}
// ------------------ End insert ------------------


Why: This will ensure the heavy depth pass and mesh generator operate on a reduced image (<= 1024 px). If you prefer faster but lower quality, set maxSize to 512.

2) Replace the try { const img = new Image(); ... } block inside the generateButton click handler

Locate this block in your file (the code that begins with try { const img = new Image(); img.crossOrigin = 'anonymous'; img.src = selectedImageBase64; ...).

Replace the whole try { ... } body (from try { to the matching } just before the catch) with the code below — this will load the image, create a resized copy, and process the resized image while still using the original image for texture if you want (we use resizedForDepth for depth and mesh generation, and pass the original img to displayMesh so texture is high-res but geometry is affordable):

try {
    // 1) Load original image (for texture & preview)
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.src = selectedImageBase64;
    await new Promise((res, rej) => { img.onload = res; img.onerror = rej; });

    // 2) Resize a copy for depth estimation & mesh generation to avoid freezing the browser.
    //    Set maxSize to 1024 (or 512 for faster results).
    const MAX_PROCESS_SIZE = 1024;
    const resizedForDepth = await resizeImageToMax(img, MAX_PROCESS_SIZE);

    showToast({ title: 'Processing image', description: 'Estimating depth map using client-side approximation...' });

    // 3) Estimate depth using the resized image (fast & deterministic)
    const estimatedDepth = await depthEstimator.estimateDepth(resizedForDepth);
    if (!estimatedDepth || !estimatedDepth.data) throw new Error('Depth estimation returned invalid data.');

    // 4) Show depth map. If depth map is smaller than the original, show the resized depth map
    //    but keep the original image for texture (so texture remains high quality)
    depthMapImageData = estimatedDepth;
    displayDepthMap(estimatedDepth);

    showToast({ title: 'Generating 3D model', description: 'Creating mesh from depth data...' });

    // 5) Generate mesh from the depth map. IMPORTANT: max pixels check is applied in generator.
    await waitForLibrary('THREE');
    const generated = meshGenerator.generateMeshFromDepth(estimatedDepth);
    if (!generated) throw new Error('Mesh generation failed.');

    generatedMesh = generated;

    // 6) Display the mesh. Pass the original high-res image for texture.
    displayMesh(generated, img);
}


Why: This ensures the expensive pixel loops operate on a limited-size image (controlled by MAX_PROCESS_SIZE), preventing long synchronous work and making the process complete quickly.

3) Optional — Add a safety timeout/logging inside the catch to reveal stack trace (replace your current catch with this if you want more debugging)

Find your current catch (err) { ... } right after the try block. Replace it with:

} catch (err) {
    console.error('Generation error:', err);
    stopViewerLoading();
    // Show an informative message with the error message and ask user to try a smaller image.
    const msg = (err && err.message) ? err.message : 'Unknown error';
    showToast({ title: 'Generation failed', description: `${msg} — try a smaller image (<=1024px)`, variant: 'destructive' });
}
